@startuml
title Turn Based RPG (1 playable character + 1 npc enemy) - UML Class Diagram

' @Enums
rectangle CharactersEnums {
    enum StatusType {
        IDLE
        READY
        DEAD
        MISSING
    }
    enum ActionType {
        ATTACK
        ABILITY
        ITEM
        WAIT
        BEGIN_TURN
    }
}
rectangle DescriptionEnums {
    enum RarityType {
        COMMON
        RARE
        LEGENDARY
    }
    enum StatType {
        STR
        INT
        DEX
    }
}

' @Interfaces
interface Usable {
    +use(user: Characters, target: Characters): void
    +isUsable(user: Characters, target: Characters): boolean
    +toString(): String
}

' @Exceptions
class MaxInstancesLimitException extends RuntimeException
class InventoryFullException extends RuntimeException
class AbilityOnCooldownException extends RuntimeException

' @Characters
abstract class Characters {
    # characterId: int
    # name: String
    # description: String
    # level: int
    # hp : int
    # inventory: Inventory
    # equippedWeapon: Weapon
    # abilities: List<Ability>
    # stats: Map<StatType, Integer>
    # status: StatusType
    # instanceCount: int

    + attack(target: Characters): void
    + takeDamage(amount: int): void
    + canAct(): boolean
    + getEquippedWeapon(): Weapon
    + equipWeapon(weapon: Weapon): void
    + getAbilities(): List<Ability>
    + addAbility(ability: Ability): void
    + removeAbility(ability: Ability): void
    + getName(): String
    + getLevel(): int
    + getHp(): int
    + getInventory(): Inventory
    + getStatus(): StatusType
    + setStatus(): void
    + getStat(type: StatType): int
    + setStat(type: StatType, value: int): void
    + toString(): String
}
class PlayableCharacter extends Characters {
    +heal(amount: int): void
    +levelUp(): void
    +rest(): void
    +loot(items: List<Item>): void
}
class Enemy extends Characters {
    +fleeChance(percentChange: int): boolean
    +dropLoot(): List<Item>
}

' @Inventory, Items, Weapons, and Abilities
class Inventory {
    -slotCapacity: int
    -items: List<Item>
    -instanceCount: int

    +addItem(item: Item): void
    +removeItem(item: Item): void
    +getItems(): List<Item>
    +totalWeight(): double
    +toString(): String
}
abstract class Item {
    #itemId: int
    #name: String
    #description: String
    #weight: double
    #rarity: RarityType
    #instanceCount: int

    +getItemId(): int
    +getName(): String
    +getDescription(): String
    +getWeight(): double
    +toString(): String
}
class Weapon extends Item implements Usable {
    -minDamage: int
    -maxDamage: int
    -critChance: double
}
class Ability implements Usable {
    -abilityId: int
    -name: String
    -description: String
    -scalingStat: StatType
    -basePower: int
    -currentCooldownDuration: int
    -cooldownDuration: int
    -instanceCount: int

    +startCooldown(): void
    +reduceCooldown(): void
    +isOnCooldown(): boolean
    +getName(): String
}

' @BattleFieldManager and TurnAction
class BattlefieldManager {
    -turnCount: int
    -turnOrder: Queue<TurnAction>
    -player: PlayableCharacter
    -enemy: Enemy
    -instanceCount: int

    +initCombat(player: PlayableCharacter, enemy: Enemy): void
    +addTurnAction(action: TurnAction): void
    +getTurnCount(): int
    +incrementTurnCount(): void
    +getTurnHistory(): List<TurnAction>
    +isBattleOver(): boolean
    +getWinner(): List<Characters>
    +toString(): String
}
class TurnAction {
    -actor: Characters
    -actionType: ActionType
    -statusType: StatusType
    -payload: Object
    -instanceCount: int

    +actor(): Characters
    +actionType(): ActionType
    +payload(): Object
    +toString(): String
}
' @UI/UX classes
class Main {
    +main(args: String[]): void
}
class Menus {
    +showLevelUpStats(player: PlayableCharacter): void
    +printCharacterComparison(character1: Characters, character2: Characters): void
    +useAbilityMenu(scanner: Scanner, player: PlayableCharacter, enemy: Enemy, bf: BattlefieldManager): Ability
    +endGameMenu(scanner: Scanner, player: PlayableCharacter, enemy: Enemy, bf: BattlefieldManager): void
}
class Scene {
    +SCREEN_WIDTH: int
    -SPRITE_SPACING: int

    +centerText(text: String): String
    +loadingScreen(milliseconds: long): void
    +clearScreen(): void
    +printBattleUI(player: PlayableCharacter, enemy: Enemy, actionText: String, bf: BattlefieldManager): void
}


' @Relationships
Characters "<color:red>1</color>" *-- "<color:red>1       </color>" Inventory
Characters "<color:red>1      </color>" o-- "<color:red>0..*</color>" Ability

Inventory "<color:red>  1</color>" o-- "<color:red>          0..*</color>" Item

BattlefieldManager "<color:red>1  </color>" o-- "<color:red>2 </color>" Characters
BattlefieldManager ..> TurnAction
Main ..> Menus
Main ..> Scene
Menus ..> Scene


note top of MaxInstancesLimitException
Each relevant classes have constructors that:
- enforce the cap of 100 instances per class
- keep track of created instances using instanceCount
end note

note left of Main
Driver class for the program.
Uses UI/UX helper classes like Menus and Scene.
end note

@enduml
